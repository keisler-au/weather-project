# controller/
## location-controls.js
**LocationFilter** <br>
Outputs two <label/> nodes with a text <input/> node inside each. The text inputs are for the user to specify "City" and "Country" locations that they wish to receive related weather data for. Each input has an "onChange" debounce event handler. After 2000ms has passed from the last typed letter the specified callback function in setTimeout will be called. The callback function retrieves relevant data by calling "getWeatherData()" and formats it by calling "parseData()". If no data is available then a formatted data template with no inclusive data is initialised to the "parsedData" variable. The newly initialised "parsedData" variable is made accessible to other components by using the "useState()" and "useContext()" React hooks, which implemented in the "setTimeout()" callback by calling "setData()". The "parsedData" variable holds a complete dataset of the retrieved/formatted data and is updated by calling "setData()". The "filteredData" variable holds a filtered version of "parsedData" which corresponds to the filters applied to each table. The data stored in "filteredData" is determined by the table columns and rows that have 'filtered' (selected and deselected).
## temperature-controls.js
**Temperatures** <br>
The "Temperatures" component outputs two <label><input/></label> radio button that the user interacts with to determine what measurement unit temperature data is displayed in. The "onChange" event handler "changeTempUnit" updates the <label> nodes CSS class names depending on their respective "checked" status. If the "data" variable contains weather data (from a user specifying a searchable location), then "convertTempData()" function is used to convert the current temperature data stored in "data" to the alternative temperature unit (celsius or fahrenheit). This updated dataset goes into intialising "filteredData", a variable used to determine what data is displayed in the user-interactive tables. The state of "filteredData" is updated by "setState()" React hook and "setFilteredData()" function.
## table-filter-controls.js
**TableFilters** <br>
Outputs an array of <label><input/></labe> checkbox controls that enable the user to select and deselect columns and rows in displayed tables. The input label names and the number of inputs are determined by the "filterOptions" prop passed in to the component. The "TableFilters" component is used to generate input controls (filters) correpsonding to tables being displayed. Clicking on a filter updates the "filteredData" variable, which determines the format/layout of the displayed tables. Clicking a filter also changes the className of that inputs parent node (<label>), which is then picked up by CSS to visually represent the changed status of that filter. The "onChange" event handler "displayFilters()" updates the state of "filteredData" via  the "useState()" React hook and "setFilteredData()". The user has the option of deselecting/selecting all corresponding filters, or selecting/deselecting a single filter. The logic applied in "displayFilters()" determines which option the user has chosen and updates the relevant classNames and the "filteredData" variable accordingly. Updating the "filteredData" variable differs if the input control selected is associated as a 'categories shown' filter or 'days shown' filter, and so additional logic is also applied to complete these operations. This logic has been seperated into "selectCategory()" and "selectedDays" unit functions. 
# model/
## api-requests.js 
contains two functions to facilitate data requests to "OpenWeather" API's. 
<br> **requestApi** <br>
uses the "fetch" API to make a request to "OpenWeather", using one of two url potential URL's. The first URL is for the "Geocoding API" which is provides location data on the specified 'city' and 'country' parameters, this URL is chosen when the "location" parameter is set to "true". The alternative URL is for "One Call API" which provides weather data for the specified 'longditude' and 'latitude' and coordinates (retrieved from the first API call). A "catch()" method logs any errors caught in the "fetch()" call.
<br> **getWeatherData**<br>
The logic in "getWeatherData()" reflects how the "country" parameter in the API request is optional (providing more specificity on the user's desired location) while the "city" parameter is needed to make a valid API request. "getWeatherData()" is called when a user finishes typing a value into the 'city' or 'country' text inputs. If the 'country' input is typed into, and the 'city' input already has an entered value, then an API request is made with both "city" and "country" values as parameters. If 'country' input is typed into and the 'city' input does not already have an entered value, then no API request is made. Alternatively, if 'city' input is typed into, an API request is made regardless of whether 'country' input has a value or not. A "catch" block logs a specific message if the error caught is "TypeError", as this indicates that the response from a request did not contain any data. Alternatively, any other type of error is logged to the console.
## parsing-data.js
has three functions; "convertTempData", "getDateString", and "parseData". 
<br> **convertTempData** <br>
takes in a "data" object, and converts the "Temperature" attribute value from celsius to fahrenheit or vice versa if the 'fahrenheit' radio button is checked. 
<br> **getDateString** <br>
takes in a unix timestamp and converts it to 24hr time string representation, or a day and date string representation depending on whether the "time" parameter is true or false.
<br> **parseData** <br>
takes in a "data" object, the response from a request to "OpenWeather API". The object gets unpacked for the relevant values inside a 'try block', and are defined to a new formatted object template "parsedData". Unix timestamps are converted to strings ("getDateString"), measurements are rounded, and descriptions are capitalised. The unpacked temperature data is in degrees celsius, so if the 'fahrenheit' radio button is checked, "convertTempData" is used to convert that temperature data to fahrenheit. The parsed data set is then returned. A TypeError occuring due to unpacking the object will be caught by the 'try block', with a specific message is logged to the console. This is likely to occur when the "data" object passed into "parseData" is empty or if does not follow the standardised format. Otherwise all other errors will be logged to the console with a generic error message. If an error is caught, the same formatted object template is returned but as an empty data set, with no assigned values.
## filtering-data.js
**filtering-data** <br>
creates a new "filteredData" object using the 'categories' in "filteredCategories" that are set to 'true', and their corresponding data points in "data". As a user clicks on an input checkbox (filter), this updates the "filteredCategories" object, and the "filteredData" object respectively. A 'for loop' iterates through both 'current' and 'daily' tables of "filteredCategories", with another 'for loop' iterating through each category for that table. If the category is set to 'true', "addCategoryMetric()" adds the unit metrics to the category header (string), which then gets assigned to "filteredData" as a key, with it's value being its corresponding data point in "data". Each category in the 'daily' table may hold several data points for each day that has been selected to display by the user, the data points to include for each category is represented and implemented by the numbers in the "daysIncluded" array.
# view/
## all-table-components.js 
contains three React components used to generate the display tables; "DayHeaders", "CreateRows", and "Tables". 
<br> **DayHeaders** <br>
returns a row of <th> nodes. The number of nodes corresponds to the number of integers in the "daysIncluded" array. The text content for each node corresponds to the "Date" attribute in "data". If there is no data in "Date", then the text content becomes 'Day x', with x being the currently iterated integer in "daysIncluded". This component is called inside "Tables", and is only expected for the table titled "8 Day Forecast" as it is the only table with more than two columns. 
<br> **CreateRows** <br>
accepts a "tableContent" prop that it maps through, with the iterated information determining what rows get added 'classNames' and how many <td> nodes to generate. If the 'data' inside "tableContent" is an array, then a <td> node is generated for each item in the array, otherwise if 'data' is not an array then a single <td> node is generated. 
<br> **Tables** <br>
is a component that returns an array of three <table> nodes, by using the "DayHeaders" and "CreateRows" components. Each table has an associated input control (checkbox) with an 'onChange' event handler that changes the icon of the <label> node and hides the table when it is checked. 
The "app.js" module contains the main "App" component that combines the other 'unit' components. "FilterFieldsets" returns an array of <div> nodes and React components, isolating logic that would otherwise by in "App" and thus making it more readable. "ErrorBoundary" is a class that renders a custom error message when an error is caught in one of it's child components. 
## app.js
**App** <br>
contains the main "App" component that combines the other 'unit' components and "FilterFieldsets", "ErrorBoundary" components.
<br> **FilterFieldsets component** <br>
returns an array of div nodes and React components, isolating logic that would otherwise by in "App" and thus making it more readable.
<br> **ErrorBoundary component** <br>
Is a class component that renders a custom error message when an error is caught in one of it's child components. 

